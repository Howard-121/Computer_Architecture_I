***Lab 2 Report (EE 469)***

Che-Hao Hsu

4/22/2022

Procedure:

Lab2 consists of two tasks. The first task is to build a single cycle arm processor by inserting the alu and register file that I created in Lab1 into the datapath of the processor. Also, the arm processor should be connected with instruction memory and data memory under the top file (top.sv). Then, the circuit needs to implement ADD, SUB, AND, ORR, LDR, STR, and B instructions. The second task is to extend the functionality of the circuit in Task1. I add a new control signal, FlagWrite, to decide when the ALUFlags should be stored in a new register, FlagsReg. By checking Instr[31:28] and FlagsReg, the updated arm processor can implement conditional execution of instructions, including BEQ, BNE, BGE, etc. Finally, I simulate both circuits on ModelSim and verify the output signals.

Task #1

In this task, I insert the 16*32 register file and the alu unit into the single cycle arm processor, which is connected with instruction memory and data memory. In addition to the two 1-bit input, clk and rst, to control sequential circuits, the processor also has two 32-bit inputs, Instr and ReadData, which connect to the output of instruction memory and data memory respectively. In terms of outputs, it has a 1-bit MemWrite linking to the write enable port of data memory as a control signal. Besides, the 32-bit output PC attaches to the input of instruction memory and points to which instruction should be executed. Two 32-bit outputs, WriteData and ALUResult, are also included and connected with data memory. WriteData sends out the value that should be written in the memory, while ALUResult denotes which address the value is supposed to stay in. The important thing we need to note is that the read from R15 is replaced by additional logic. To be more specific, if the read address of register file equals 15, it won’t take PCPlus8 at R15. Instead, the two multiplexers inserted between RD1 and SrcA or between RD2 and WriteData will choose PCPlus8.






Given the testing program “memfile.dat”, I make a table showing the first 19 cycles of processor’s execution, as seen in Table 1.

![Table 1](https://github.com/Howard-121/Computer_Architecture_I/blob/master/Single_Cycle_Processor/images/first%2019cycles%20of%20executing%20memfile.png)

Table 1: First 19 cycles of executing memfile.dat

Task #2

In this task, I include the instructions of comparison (CMP) and conditional branches (BＸＸ) to the processor. As for CMP, since the instruction is similar to subtraction, and the only difference is the condition flag, I merge both together in the RTL code. If processor detects subtraction type of instruction and the condition flag (Instr[20] ) equals 1, the control signal, FlagWrite, will be asserted and the new register, FlagsReg stores ALUFlags. With the flags, the following branch is able to do conditional execution. First, Instr[31:28] is required to identify which conditional branch we’re going to execute. Second, I utilize the FlagsReg to check if the flag matches the condition. If they match, PC will jump to the expected address, otherwise the branch will be ignored. The PC sequence for the memfile2.dat is shown in Table2.



<p align = "center">
<img src="https://github.com/Howard-121/Computer_Architecture_I/blob/master/Single_Cycle_Processor/images/PC%20sequence%20for%20the%20memfile2.png" width="500" height="600" />
<p align = "center">
Table 2: PC sequence for the memfile2.dat




Results:

Task #1

I run ModelSim on the single cycle arm processor that I create. It shows PC, instructions, ALUResult, WriteData, MemWrite, ReadData, and the internal values in the register file, as seen in Figure 1.

![Figure 1](https://github.com/Howard-121/Computer_Architecture_I/blob/master/Single_Cycle_Processor/images/SingleCycle_Task1.png)

Figure 1: The waveform generated by single cycle arm processor


After the reset, PC is set to zero and increases by four every cycle until the cycle 10. Since the instruction in cycle 10 is branch, PC jumps to address 30 (hex) and is finally stuck in the loop instruction at address 34 (hex). Besides, the values of ALUResult are one by one stored in register file from R0 to R7. Then, the value in R7 is stored in memory at address R1 in cycle 9. Two cycles later, since the instruction asks the value at address R1 to be loaded, we can see ReadData equal the value, R7. Next cycle, the value in R7 is successfully stored in R8 in the register file. 










Task #2

I run ModelSim on the updated single cycle arm processor that I create. It shows PC, instructions, ALUResult, WriteData, MemWrite, ReadData, and the internal values in the register file, as seen in Figure 2.
 
![Figure 2-1](https://github.com/Howard-121/Computer_Architecture_I/blob/master/Single_Cycle_Processor/images/SingleCycle_Task2_1.png)
![Figure 2-2](https://github.com/Howard-121/Computer_Architecture_I/blob/master/Single_Cycle_Processor/images/SingleCycle_Task2_2.png)

Figure 2: The waveform generated by updated single cycle arm processor

This updated arm processor is able to execute the comparison and conditional branch. In cycle12, R6 is compared with 15. Because they are equal, R9 becomes 0 and the information is recorded in ALUFlags. The next instruction performing not-equal branch is ignored since the flag signal shows they’re equal. The similar cases also happen in cycle16 and cycle20. However, for cycle14, cycle18, and cycle22, the flag signals match the conditional branches, so PC skips a few instructions and jumps to the assigned address. Finally, R1 which is 0 is added to 1 and the value goes to R8.
