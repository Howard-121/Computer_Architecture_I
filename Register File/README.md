***Lab 1 Report (EE 469)***

Che-Hao Hsu

4/8/2022


Procedure:

Lab 1 consists of two tasks. 
The first task is to create a 16*32 register file by using SystemVerilog on Quartus. 
The second task is to build an ALU that performs addition, subtraction, AND, OR operations, along with a 4-bit ALUFlags output to show overflow, carry out, zero, or a negative result. 
Finally, I simulate both circuits on ModelSim and verify the output signals.


Task #1

I use RTL to create a 16*32 register file with two 32-bit read ports, one 32-bit write port, and asynchronous reading, as seen in Figure 1.


![Figure 1](https://github.com/Howard-121/Computer_Architecture_I/blob/master/Register%20File/images/block%20diagram%20of%20regfile.png)
Figure 1: Block diagram of a register file


The 4-bit write_addr tells the register file where the write_data should be stored, and the input data is controlled by the write enable signal, wr_en. 
The write_data can be written to the register file only when wr_en equals 1 and at the posedge of clk. Given that the register file performs asynchronous reading, the two outputs, read_data1 and read_data2, are not subject to clk. They should both return the corresponding values after new reading addresses are supplied, and data have been stored in the addresses, so I use “assign” to implement data reading in SystemVerilog.




Results:

Task #1

I run ModelSim on the register file. It shows inputs, outputs, and internal values in the register, as seen in Figure 2.


![Figure 2](https://github.com/Howard-121/Computer_Architecture_I/blob/master/Register%20File/images/waveform.png)
Figure 2: The waveform generated by register file


All values in the waveform are displayed in hexadecimal. In terms of writing data into the register file, the write_addr is initially set as 1 and the write_data is 0000000a, but the data isn’t written in address1 at the posedge of clk because wr_en equals 0 at that point. However, in the next clock cycle, after I switch wr_en to 1, the write_data is successfully written in address1 at the posedge of clk. In terms of reading data, I set 0 to read_addr1 and 1 to read_addr2. In the beginning, there are no values in both addresses, so read_data1 and read_data2 remain unknown. However, as soon as I store 0000000a in address1, read_data2 which is currently at address1 returns 0000000a, and read_data1 is also updated to the value in address0, 00000004, at sixth clock cycle. If we take a look at the ninth clock cycle, the write_addr and the read_addr1 are set to 3, and wr_en is enabled. As we can see in the waveform, as soon as the write_data, 00000064, is stored in address3, the read_data1 immediately changes to 00000064, like write_data, because they both point to the same address at this time.