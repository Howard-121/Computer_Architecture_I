***Lab 3 Report (EE 469)***

Che-Hao Hsu

5/06/2022

Procedure:

Lab 3 mainly includes two parts: pipelining and hazard addressing. In contrast with the single cycle processor, the pipelined processor has five stages: Fetch, Decode, Execute, Memory, and Writeback, which are divided by four pipeline registers. Not only the values but also all control signals should go through these registers cycle by cycle. Also, I set all data to be written in the register file at the negative edge of clock. On the other hand, when it comes to pipeline structure, the data hazard and control hazard will also come along because sometimes the value that we tend to use for calculation hasn’t been stored in the register file, or the next instruction address hasn’t been certain until the values enter the Execute stage. Therefore, I adjust my original circuit and make a hazard unit to detect potential hazards and address them with corresponding actions. The change makes the processor be able to do forwarding, stalling, flushing, and early BTA determination.

In this lab, I build the pipelined processor based on the single cycle processor that I did in Lab2 by inserting four pipeline registers, BranchTakenE signal and ALUResultE feedback for early BTA, ALUOutM and WA3W feedback for data forwarding, and a hazard unit for stalling and flushing, as seen in Figure 1.
 


<p align = "center">
<img src="https://github.com/Howard-121/Computer_Architecture_I/blob/master/ARM%20Pipelined%20Processor/images/Block%20Diagram.png" width="700" height="550" />
<p align = "center">
Figure 1: The block diagram of ARM Pipelined Processor




Data Forwarding:

There are two cases that cause data hazard. If RA1E equals WA3M or WA3W, and we’re sure the value is going to written back in register file (RegWriteM = 1), then data hazard occurs and the idea is the same with RA2E. I deal with it by data forwarding. RA1E, RA2E, WA3M, WA3W, RegWriteM, and RegWriteW are sent to hazard unit to produce ForwardAE and ForwardBE as control signals that determine if data forwarding is needed.

Stalling Logic:

Once we run into the data hazard with load instruction, the stalling is required for Fetch and Decode stage to wait for the value stored back to register file. If RA1D or RA2D equals WA3E, and we’re sure it’s a load instruction (MemtoRegE = 1), that means Fetch and Decode stage should be stalled, and Execute stage should be flushed to remove unnecessary data in datapath.

Early Branch Resolution:

Normally, we need to wait four cycles to know where the next instruction is if branch happens, but we can actually find the destination beforehand by looking at ALUResultE. Thus, I add a multiplexer before PC register to select BTA from ALUResultE by BranchTakenE signal, which is asserted only if branch occurs. Plus, once BranchTakenE is asserted, Decode and Execute stage will be flushed to remove unnecessary data in datapath.

Results:

I run ModelSim on the ARM pipelined processor. It shows PCF, instrF, BranchTakenE, ResultW, ALUOutM, SrcAE, and the internal values in the register file, as seen in Figure 2, Figure 3, and Figure 4.

![Figure 2](https://github.com/Howard-121/Computer_Architecture_I/blob/master/ARM%20Pipelined%20Processor/images/pipelined%20processor%20waveform1.png)

Figure 2: The waveform generated by pipeline processor

In the cycle c (PCF = c), we see the case of forwarding from the memory stage to the execute stage. The value at ALUOutM(memory stage) is sent to SrcAE(execute stage) since the hazard unit detects the data hazard (R0). We can also see the case of forwarding from the writeback stage to the execute stage in the cycle 10 (PCF = 10). The value at ResultW(writeback stage) is sent to SrcAE(execute stage) since the hazard unit detects the data hazard (R0).

![Figure 3](https://github.com/Howard-121/Computer_Architecture_I/blob/master/ARM%20Pipelined%20Processor/images/pipelined%20processor%20waveform2.png)

Figure 3: The waveform generated by pipeline processor

The branch instruction is at fetch stage in cycle 14 (PCF = 14), so the next instruction (PCF = 18) should be stalled for two cycles as shown in Figure 3.

![Figure 4](https://github.com/Howard-121/Computer_Architecture_I/blob/master/ARM%20Pipelined%20Processor/images/pipelined%20processor%20waveform3.png)
 
Figure 4: The waveform generated by pipeline processor

The load instruction is at the fetch stage in cycle 28 (PCF = 28), and the data hazard with load occurs in the next instruction (AND). As the AND instruction enters the decode stage (PCF = 30), it should be stalled for one cycle as shown in Figure 4.
